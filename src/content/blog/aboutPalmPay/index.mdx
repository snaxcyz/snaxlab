---
title: hh
date: 2025-09-25
description: jida qiziq narsa
---

Hammanglar nazarimda kaft bilan to'lov qilish tizimi MyIdPalm haqida eshitgan bo'lsanglar kerak. 

Tajriba haqida yozishdan oldin avval shuni qanday ishlashi haqida ozroq nimadirlar gapirsam:
  Uzinfocom va boshqa tashkilotlar tomonidan amalga oshirilayotgan bu loyihada hozirda 100 ga yaqin dasturchilar ish olib boryapti, men ham ular orasidan borman(sezgan bo'lsanglar maqtanyapman)
  Hop bu qanday ishlaydi biometrik ma'lumotlar barmoq izi bilanmi deydigan bo'lsanglar, yo'q bunday emas, aksincha buning uchun sizning kaftingizdagi vena qon tomirlari ishlatiladi ha shunaqa. A unda ma'lumotlarda aralashib ketmaydimi deb savol berishlaring ham tabiiy, yo'q bunaqa holat kuzatilmaydi, chunki dunyoda 8 milliard odam bo'lsa, har bir odamniki o'ziga xos bo'ladi, va nu bilan sistemani ham aldab bo'lmaydi.

  Aniqroq tushuntiradigan bo'lsam, skaner sizni kaftingizdagi gemoglobinga to'yingan tomirlarni yoritadi, va ularni aniq tasvirga oladi, shu tarzda sizni kaftingizdagi vena tomirlari raqamli malumotga o'g'iriladi.

  (Toshkent metrolarida bu xizmat mavjud, metroni o'zida registratsiya qilib foydalanib ko'ringlar)

## To'lov jarayonini tezlashtirish

Aytganimdek dastlabki sinovlar metroda bo'lgan, a metro odamlar ko'p bo'ladi, dastlab to'lov jarayoni 3 s dan 5 sekundgacha cho'zildi va bu tabiyki odamlarda kartadan to'lov qilgan yaxshi degan xulosaga olib keldi. (karta to'lovlar 1 2 s)
keyinchalik biz kriptografik algoritmlar bilan shifrlash g'oyasi kelib qoldi, bu userga maksimal qulaylik berardi ammo dasturiy ta'minot, enginering va database jihatdan bizni ancha qiynab qo'ydi.
Nima qilish kerak edi, biz AES-256 va RSA shablon shifrlaydigan dasturlarni qo'lladik va ularga kriptografik algoritmlarni uladik, shunda malumotlar biometrikk ma'lumot bo'lib emas balki shifrlangan token sifatida serverlarga boradi, server esa tokenni juda tez o'qiy oladi. 

bunda:

   Foydalanuvchi ma'lumoti foydalanuvchi nomi bilan ro'yxatga olinmaydi ya'ni Rahmatillo Mahmudjonovning kaft malumoti emas mana bunday tarzda ro'yxatga olinadi:

   14cdb9b4-de01-3faa-aff5-65bc2f771745

ammo bunda ham yetarlicha muammo bor edi, serverlar tepadagi tokenni bemalol o'qiy oladi ammo malumot tasdiqdan qaytganda, ya'ni tasdiqlangan infoni qabul qilib olgan qurilma bu tokkeni tanib ola olmasdi.

Bu yerda ham nimadir o'ylab topish kerak edi, shu narsa men ishlaydigan jamoaga yuklatildi.
Muammoni xal qilish uchun 4 ta narsani qo'lladik
 1. ILI9486 datashet bu yordamida bil paralel ma'lumotni 8-bit/16/18 va 8080-style ko'rinishiga olib keldik, interfeys qo'llanishi uchun
 2. RGB interface - Displey modulida ma’lumotni to‘g‘ridan to‘g‘ri RGB datasi bilan uzatish imkoniyati bo‘lishi uchun
 3. MIPI DSI - bu RGB interface ni muqobil ishlashi uchun kerak edi
 4. Serial interface (3-wire / 4-wire SPI) -  ILI9486 modullarda 3- yoki 4- liniyali SPI interfeys qo'llash uchun

 shular yordamida jarayonni 1 2 sekund qilib va shu vaqt oralig'ida ma'lumot serverga token ko'rishida borib, tasdiqlanib qaytishda yana biometrik holatga kelishiga erisha oldik. (bir oy kuniga 20 soat ishladik)



 Keyingi qadamlarda butun dasturiy taminotni odam bashara qilish bilan o'tdi, openvible, RND lar yozilib hozirgi holatga yetib keldi loyiha.

## Qurilma elektronikasi

Loyihani kodlari, algoritmlarini ozroq tartibga solib olganimizdan so'ng yana, dasturiy OS haqida o'ylab qoldik, open-source ishlatish maqul deb topdik ammo boshqa qurilmalarni bunga moslash ham yetarlicha bosh og'riq bo'ldi. Adaptatsiya jarayoni uchun ham OS ham c dan 0 dan interfeys yozisjga to'g'ri keldi. UI qilish ham C asosida bo'ldi. Umumiy qurilma va os uchun alwinner h2+ va h3 chipsetlari olindi chunki biz linux formatda qilganimiz bilan foydalanuvchular android yoki ios ishlatishi keyin tepib qoldi. Shuning uchun iltek 9486 DTS yozishga ham to'g'ri keldi.

## DTS 
linux yadrosini aparat ta'minotiga moslab kompinatsiya qilish, android, ios , metrolardagi rasberryPi lar bilan muammo keltirib chiqardi, Birini infosi serverga o'tsa biriniki yoq 404 .
Bug ni to'g'irlash uchun kimga yuklandi hay? Men ishlayotgan jamoga, ertalab ishga kelsam jamoadagi hamma o'zini bumagaga osishga tayyor. Biz naq bir hafta o'o'o'otirib o'yladik, o'tiraverib ko'tlarimiz to'rtburchak bo'lib ketdi va oxiri evrika

 ### Device Tree
 Device Tree — bu apparat resurslarini ta’riflovchi ma’lumotlar tuzilmasidir. U Linux yadrosiga: qurilmalar qanday manzillarda joylashgan, u qanday turdagi qurilma, qanday parametrlar bilan ishlaydi kabi savollarga javob beradi. Yadro bu ma’lumotlar asosida qurilmalar uchun drayverlarni yuklaydi va sozlaydi.Bunga ko’ra dts (Device Tree’ning) odam o’qiy oladigan matn ko’rinishidagi faylidir. U apparat haqida tuzilgan iyerarxik tuzilmadagi yozuvlardan iborat bo’ladi. Faylda har bir qurilmalar uchun ehtiyojlarga qarab node kiritiladi va uyerda qurilmaga doir xususiyatlar yoziladi. Shundan so’ng dts fayl yakunida dtb (device tree blob) fayliga kompilatsiya qilinadi, bu esa o’z navbatida Linux yadrosi tomonidan ishlatiladi.  Device tree yordamida esa bitta umumiy yadro ko’plab qurilmalarda ishlashi mumkin bo’ladi va bu jarayonda faqat dts (ya’ni konfiguratsiya) fayli o’zgaradi.
### Ish prinsipi
DTS fayllar sintaksisi xuddi json kabi ammo ancha kengaytirilgan holda yoziladi. Unda asosan qaysi chiplar bilan mos kelishi va modulning xususiyatlari kiritiladi:

```
/dts-v1/;
/plugin/;

/ {
    compatible = "brcm,bcm2835";

    fragment@0 {
        target-path = "/";

        __overlay__ {
            mygpioled: gpioled@0 {
                compatible = "test,gpioled";
                gpios = <&gpio 17 0>;
                status = "okay";
            };
        };
    };
};
```

1. /dts-v1/ - ushbu majburiy direktiva dts sintaksisining versiyasini belgilaydi. Kompilyator (dtc) bu bilan fayl formatini aniqlaydi va shunga moslab blob faylga olib o’tadi.

2. /plugin/ - Bu direktiva mavjud dts iyerarxiyasiga qo’shimcha kiritilayotganini bildiradi. Odatda bu jarayon mavjud device tree ustiga qo’shimcha qilish uchun ishlatiladi. Bunda asl dts faylni o’rgartirmasdan uni keygaytirish va unga qo’shimchalar kiritish mumkin.

3. compatible - bunda device tree qaysi platformaga mos ekanligi kiritiladi. Yuqoridagi misolda broadcom chiplari uchun misol keltirilgan bo’lsa dts ning boshqa qismlari ham (pinlar, interfeyslar, protokollar) aynan shu chip xususiyatlaridan kelib chiqib shakllantiriladi.

4. fragment@0 - Fragmentlar odatda mavjud device treening muayyan joyiga yangilik (patch) qo’shadi. Yuqoridagi misolga asosan biz yadroga yangi qurilma (gpioled@0) qo’shmoqchimiz.

5. gpios - bu device treedagi GPIO kontrollerga label bo’yicha murojaat qilishni bildirib yuqoridagi misolda brcm chipning GPIO17 qismiga murojaat qiladi.

6. status - bu qurilma statusini belgilaydi, odatda dts orqali qurilma faolligini boshqarish mumkin.

Kompiliyatsiya qilish:
```
dtc -I dts -O dtb -o gpio-led.dtbo gpio-led-overlay.dts
sudo cp gpio-led.dtbo /boot/overlays/
```

Shundan so’ng /boot/config.txt faylning eng oxiriga yadro qurilmani yuklashi uchun quyidagi qo’shimchani kiritish lozim.

```dtoverlay="value"```

Shu bilan bo'ldi desak muammoni to'g'irlabmizku lekin boshqa muammoni o'zimiz ochib qo'yibmiz

### Baza fayllar 
 Eng bosh o'g'riq bo'lgan narsa shu, php va c orasida baza fayli almashinishga to’g’ri kelib qoldi. PHPdagi struktura json ustiga qurilgan ammo buni Cda qayta ishlash toza bosh og’riqlardan biri, shu sababli o’zimiz strukturaviy baza ko’tarishga qaror qildik. Bu yerda ham muammo bor edi, asosiy muammo bu strukturada emas, balkim struktura faylini qisqartirishda edi.kalit so’zlarni indeksatsiya qilish zarurati bor, bu degani yetarli katta hajmdagi matn fayli hosil bo’ladi. Demak hajmni qisqartirish kerak. Shu yeriga kelganda butun jamoa  David Huffmanga raxmat aytdi, raxmatli bizni yana bir hafta o'tirib qolishdan qutqardi.
Barcha muammolarni yechish uchun Hufman algoritmini qo'lladik

## Huffman Algoritmi
 1952-yilda David Huffman tomonidan ishlab chiqilgan ushbu algoritm kirish sifatida berilgan ma’lumotni undagi belgilar qatnashish chastotasi yoki o’rniga qarab qisqaroq kodlar bilan belgilashni o’z oldiga maqsad qilib qo’yadi.

 ### bosqichlari

  1. masalan "salom dunyo" malumoti

  Algoritm kirish ma’lumotlaridagi har bir belgining chastotasini tahlil qilishdan boshlanadi.

```
s: 1
a: 1
l: 1
o: 2
m: 1
(space): 1
d: 1
u: 1
n: 1
y: 1

```
2. strukturaviy asos yaratish. Bu bosqichda Huffman daraxti deb ataladigan ikki o’lchamlik massivni oziga struktura deb oladigan to’plam quriladi. Daraxt sifatida qaralganda bu yerda har bir barg tugunlari belgi va uning chastotasini ifodalaydi.
Barg tugunlari:
```
(s:1) (a:1) (l:1) (o:2) (m:1) (space:1) (d:1) (u:1) (n:1) (y:1)
```
Huffman daraxti:
```
                   (o:2, s:1, a:1)
                   /             \
          (o:2)                 (s:1, a:1)
          /    \                 /          \
    (o:2)     (space:1)    (s:1)           (a:1)
                           /   \           /    \
                      (l:1) (m:1)      (d:1) (u:1, n:1)
                                           \
                                           (y:1)
```

Kodlarni ajratish:

Har bir belgilar daraxtdagi chap va o’ng harakatlar mos ravishda ikkilik sanoq tizimida belgilab chiqiladi.

```
s: 010
a: 1101
l: 1111
o: 101
(space): 1100
d: 1110
u: 011
y: 100

```
Huffman kodlari jadvalini yaratish:

Yakuniy bosqich har bir belgiga tegishli Huffman kodi bilan taqqoslaydigan jadval yaratishni o’z ichiga oladi.

Natija:

0101101111110100011001110011001100101 

Shunday qilib bizda token info bor


Shunaqa o'rtoqlar, tanishlar, tanishlariimning tanishlari. O'zi oxirgi kunlarda 7500+ odam postlarimni o'qiyapti, meni shuncha tanishim yo'q qayerdan kelyapsilar)
